<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>14&nbsp; Quantified Modal Logic – Modal Logic</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./conditionals.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-626149efe8f5d16e1d391ba177679bf0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./tense.html">Applications</a></li><li class="breadcrumb-item"><a href="./quantmodal.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Quantified Modal Logic</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modal Logic</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Introduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Why Modal Logic?</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./background.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Background</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Propositional Logic</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./propositional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Basic Language</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./derivations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Axiomatic Derivations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./completeness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Completeness</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Modal Propositional Logic</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./modalpropositional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Basic Language</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./modalderivations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Axiomatic Derivations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./modalcompleteness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Completeness</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Applications</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tense.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Tense Logic</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./choice.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Tense and Choice</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./deontic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Deontic Logic</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./epistemic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Epistemic Logic</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conditionals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Conditionals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./quantmodal.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Quantified Modal Logic</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation"><span class="header-section-number">14.1</span> Motivation</a></li>
  <li><a href="#basic-language" id="toc-basic-language" class="nav-link" data-scroll-target="#basic-language"><span class="header-section-number">14.2</span> Basic Language</a></li>
  <li><a href="#the-simplest-modal-quantificational-logic" id="toc-the-simplest-modal-quantificational-logic" class="nav-link" data-scroll-target="#the-simplest-modal-quantificational-logic"><span class="header-section-number">14.3</span> The Simplest Modal Quantificational Logic</a>
  <ul class="collapse">
  <li><a href="#the-converse-barcan-formula" id="toc-the-converse-barcan-formula" class="nav-link" data-scroll-target="#the-converse-barcan-formula">The Converse Barcan Formula</a></li>
  <li><a href="#the-necessity-of-existence" id="toc-the-necessity-of-existence" class="nav-link" data-scroll-target="#the-necessity-of-existence">The Necessity of Existence</a></li>
  <li><a href="#the-barcan-formula" id="toc-the-barcan-formula" class="nav-link" data-scroll-target="#the-barcan-formula">The Barcan Formula</a></li>
  <li><a href="#the-necessity-of-identity" id="toc-the-necessity-of-identity" class="nav-link" data-scroll-target="#the-necessity-of-identity">The Necessity of Identity</a></li>
  <li><a href="#the-necessity-of-distinctness" id="toc-the-necessity-of-distinctness" class="nav-link" data-scroll-target="#the-necessity-of-distinctness">The Necessity of Distinctness</a></li>
  </ul></li>
  <li><a href="#free-quantified-modal-logic" id="toc-free-quantified-modal-logic" class="nav-link" data-scroll-target="#free-quantified-modal-logic"><span class="header-section-number">14.4</span> Free Quantified Modal Logic</a>
  <ul class="collapse">
  <li><a href="#free-quantificational-logic" id="toc-free-quantificational-logic" class="nav-link" data-scroll-target="#free-quantificational-logic">Free Quantificational Logic</a></li>
  <li><a href="#kripke-on-universal-instantiation" id="toc-kripke-on-universal-instantiation" class="nav-link" data-scroll-target="#kripke-on-universal-instantiation">Kripke on Universal Instantiation</a></li>
  </ul></li>
  <li><a href="#semantics" id="toc-semantics" class="nav-link" data-scroll-target="#semantics"><span class="header-section-number">14.5</span> Semantics</a>
  <ul class="collapse">
  <li><a href="#constant-domain-models" id="toc-constant-domain-models" class="nav-link" data-scroll-target="#constant-domain-models">Constant Domain Models</a></li>
  <li><a href="#variable-domain-models" id="toc-variable-domain-models" class="nav-link" data-scroll-target="#variable-domain-models">Variable Domain Models</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./tense.html">Applications</a></li><li class="breadcrumb-item"><a href="./quantmodal.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Quantified Modal Logic</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Quantified Modal Logic</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Quantified modal logic supplements the vocabulary of quantificational logic with a modal operator <span class="math inline">\(\Box\)</span>. The simplest quantified modal logic extends the axioms of quantificational logic with substitution instances of <span class="math inline">\(\textsf{K}\)</span> and the rule of necessitation. We will explain how to construct possible worlds models for the language of quantificational modal logic.</p>
<section id="motivation" class="level2" data-number="14.1">
<h2 data-number="14.1" class="anchored" data-anchor-id="motivation"><span class="header-section-number">14.1</span> Motivation</h2>
<p>By way of motivation, we briefly look at the expressive resources we gain when we combine quantification and modality.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
De Re v De Dicto
</div>
</div>
<div class="callout-body-container callout-body">
<p>There are at least two interpretations of the English sentence:</p>
<ol type="1">
<li>Someone rich could have been poor.</li>
</ol>
<p>On the one hand, there is a <em>de dicto</em> interpretation on which we qualify the proposition that somone rich is poor:</p>
<p>1a. Possibly, someone rich is poor.</p>
<p>On the other hand, there is a <em>de re</em> interpretation, which qualifies the way in which some individual person is rich:</p>
<p>1b. Someone who is rich is possibly poor.</p>
<p>Quantificational modal logic allows one to capture that distinction:</p>
<p><span class="math display">\[
\begin{array}{lll}
1a &amp; \Diamond \exists x (Rx \wedge Px) &amp; \text{(de dicto)} \\
1b &amp; \exists x (Cx \wedge \Diamond Px) &amp; \text{(de re)} \\
\end{array}
\]</span></p>
</div>
</div>
<p>This distinctions help dispel what might otherwise be thought to be puzzles on the interaction between predication and modality. Furthemore, the framework allows one to make a common distinction between <em>essential</em> and <em>accidental</em> attributes.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Essence and Accident
</div>
</div>
<div class="callout-body-container callout-body">
<p>One common distinction between a statue made of clay and the portion of clay of which it is made is that while they exemplify a certain shape, the shape is an <em>essential</em> attribute of the statue and an <em>accidental</em> attribute of the clay of which it is made. One way to articulate the distinction makes use of de re modality:</p>
<ul>
<li><p><span class="math inline">\(F\)</span> is an <em>essential</em> attribute of <span class="math inline">\(x\)</span> if, and only if, <span class="math inline">\(\Box Fx\)</span>.</p></li>
<li><p><span class="math inline">\(F\)</span> is an <em>accidental</em> attribute of <span class="math inline">\(x\)</span> if, and only if, <span class="math inline">\(Fx \wedge \neg \Box Fx\)</span>.</p></li>
</ul>
<p>This is, however, just a provisional characterization of the distinction, since it is not well-suited to accommodate the contingent existence of the statue and the clay.</p>
</div>
</div>
<p>W. V. O. Quine had a more serious objection to the very intelligibility of quantified modal logic. His objection is premised on a certain interpretation of the modality involved in the language of quantified modal logic. Like Carnap and others before him, he took the modality to be linguistic at heart. To claim that necessarily, all bachelors are unmarried is to assert, on their view, that the sentence ‘all bachelors are unmarried’ is analytic or true in virtue of the meaning of the terms involved. What else, they may add, could the necessity involved be?</p>
<p>That interpretation is ill-suited to make sense of quantified modal logic. For compare the truth conditions of the two sentences below:</p>
<ul>
<li><p><span class="math inline">\(\Box \exists x Fx\)</span></p>
<p>For Quine, this sentence is true if, and only if, the sentence <span class="math inline">\(\exists x Fx\)</span> is analytic.</p></li>
<li><p><span class="math inline">\(\exists x \Box Fx\)</span></p>
<p>This sentence is true if, and only if, the <em>open formula</em> <span class="math inline">\(\Box Fx\)</span> is true relative to an assignment of an object to the individual variable <span class="math inline">\(x\)</span>. If <span class="math inline">\(\Box Fx\)</span> is true relative to an assignment if, and only if, <span class="math inline">\(Fx\)</span> is analytic relative to that assignment. But what could that mean? Closed sentences may be true or not in virtue of the meaning of the terms involved, but it is difficult to make sense of the truth of an open formula in virtue of the meaning of the terms involved, much less the truth of an open formula relative to an assignment.</p></li>
</ul>
</section>
<section id="basic-language" class="level2" data-number="14.2">
<h2 data-number="14.2" class="anchored" data-anchor-id="basic-language"><span class="header-section-number">14.2</span> Basic Language</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Language of Quantificational Modal Logic
</div>
</div>
<div class="callout-body-container callout-body">
<p>Given an initial list of <span class="math inline">\(n\)</span>-place predicates <span class="math inline">\(R^n\)</span> and an infinite stock of variables <span class="math inline">\(v_1, \dots, v_n, \dots\)</span>, we define <em>atomic formula</em> as follows:</p>
<p><span class="math display">\[
\varphi ::= R^n v_1, \cdots, v_n \ | \ v_i = v_j \
\]</span></p>
<p>Given a set <span class="math inline">\(AT\)</span> of atomic formulas, we define a <em>formula</em> as follows:</p>
<p><span class="math display">\[
\varphi ::= AT \ | \ \neg \varphi \ | \ (\varphi \to \psi) \ | \ \forall v_i \varphi \ | \ \Box \varphi
\]</span></p>
<p>We now define familiar connectives in terms of <span class="math inline">\(\neg\)</span>, <span class="math inline">\(\to\)</span>, <span class="math inline">\(\forall\)</span>, and <span class="math inline">\(\Box\)</span>:</p>
<p><span class="math display">\[
\begin{array}{lll}
\top &amp; := &amp; (p \to p)\\
\bot &amp; := &amp; \neg \top \\
(\varphi \vee \psi) &amp; := &amp; (\neg \varphi \to \psi)\\
(\varphi \wedge \psi) &amp; := &amp; \neg (\varphi \to \neg \psi)\\
(\varphi \leftrightarrow \psi) &amp; := &amp; (\varphi \to \psi) \wedge (\psi \to \varphi)\\
\exists v_i \varphi &amp; := &amp; \neg  \forall v_i \neg \varphi \\
\Diamond \varphi &amp; := &amp; \neg \Box \neg \varphi\\
\end{array}
\]</span></p>
</div>
</div>
<p>The simplest quantified modal logic combines the axioms of quantificational logic with identity with the axioms of the minimal normal modal logic K. That will motivate a simple possible worlds model theory for the language, one that has, however, been controversial. In order to be in a position to discuss the framework, we should review the axioms of quantificational logic with identity.</p>
</section>
<section id="the-simplest-modal-quantificational-logic" class="level2" data-number="14.3">
<h2 data-number="14.3" class="anchored" data-anchor-id="the-simplest-modal-quantificational-logic"><span class="header-section-number">14.3</span> The Simplest Modal Quantificational Logic</h2>
<p>The axioms for quantificational logic with identity include:</p>
<ul>
<li><p>Substitution instances of axioms of propositional logic for the expanded language.</p></li>
<li><p>Substitution instances of the axiom of universal instantiation:</p>
<p><span class="math display">\[
\begin{array}{lll}
\forall x \ \varphi \to \varphi[y/x] &amp; &amp; (\textsf{UI})\\
\end{array}
\]</span></p></li>
</ul>
<p>where <span class="math inline">\(\varphi[y/x]\)</span> is the formula that results from <span class="math inline">\(\varphi\)</span> from the uniform substitution of occurrences of the variable <span class="math inline">\(y\)</span> for every free occurrence of the variable <span class="math inline">\(x\)</span> in the formula relettering if necessary to make sure that the resulting occurrences of <span class="math inline">\(y\)</span> remain free after the substitution.</p>
<ul>
<li>Substitution instances of Reflexivity and the Indiscernibility of Identicals for the expanded language:</li>
</ul>
<p><span class="math display">\[
  \begin{array}{lll}
  x = x &amp; &amp; (\textsf{Ref})\\
  x = y \to (\varphi \to \varphi[y/x]) &amp; &amp; (\textsf{II})\\
  \end{array}
  \]</span></p>
<ul>
<li><p>Two rules of inference, Modus Ponens and Universal Generalization:</p>
<p><span class="math display">\[
\begin{array}{lll}
\varphi, \varphi \to \psi / \psi &amp; &amp; (\textsf{MP})\\
\varphi \to \psi / \varphi \to \forall x \ \psi, &amp;  \text{$x$ is not free in $\psi$}  &amp; (\textsf{UG})\\
\\
\end{array}
  \]</span></p></li>
</ul>
<p>We are in a position prove some derived rules of inference from them: <span class="math display">\[
\begin{array}{lll}
\varphi / \forall x \ \varphi &amp; \text{provided $x$ is not free in $\varphi$}\\
\varphi \to \psi / \forall x \ \varphi \to \forall x \ \psi &amp; &amp; \\
\forall x (\varphi \to \psi)  \to (\forall x \varphi \to \forall x \psi) &amp; &amp; \\
\end{array}
\]</span></p>
<p>We now adopt all substitution instances of the axioms of quanficational logic with identity for the expanded language, which we supplement with the axioms and rules of inference for the minimal normal modal logic:</p>
<p><span class="math display">\[
\begin{array}{lll}
\Box (\varphi \to \psi) \to (\Box \varphi \to \Box \psi) &amp; &amp; (\textsf{K}) \\
\varphi / \Box \varphi &amp; &amp; (\textsf{RN}) \\
\end{array}
\]</span></p>
<p>We now derive three remarkable consequences of the axioms of quantified modal logic with identity.</p>
<section id="the-converse-barcan-formula" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-converse-barcan-formula">The Converse Barcan Formula</h3>
<p>One consequence of the axioms is the Converse Barcan Formula (<span class="math inline">\(\textsf{CBF}\)</span>):</p>
<p><span class="math display">\[\tag{$\textsf{CBF}$}
\Box \ \forall x \ \varphi \to \forall x \ \Box \ \varphi
\]</span> Here is a simple derivation schema:</p>
<p><span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \forall x \ \varphi \to \varphi &amp; &amp;  \text{UI} \\
2 &amp; &amp; \Box \ \forall x \ \varphi  \to \Box \ \varphi &amp; &amp; \text{RK} \ 1\\
3 &amp; &amp; ( \Box \ \forall x \ \varphi  \to \Box \ \varphi) \to (\Box \ \forall x \ \varphi \to \forall x \ \Box \ \varphi) &amp; &amp; \text{UG} \ 2 \\
4 &amp; &amp; \Box \ \forall x \ \varphi  \to \forall x \ \Box \ \varphi &amp; &amp; \text{MP} \ 2, 4\\
\end{array}
\]</span></p>
<p>CBF seems problematic, since it automatically gives us the necessity of existence.</p>
</section>
<section id="the-necessity-of-existence" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-necessity-of-existence">The Necessity of Existence</h3>
<p>Existence is generally understood in terms of quantification and identity: to exist is to be identical with something. But given <span class="math inline">\(\textsf{CBF}\)</span>, we now are in a position to prove that everything necessarily exists.</p>
<p><span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \forall x \ \exists y \ x = y &amp; &amp;  \text{QL} \\
2 &amp; &amp; \Box \ \forall x \ \exists y \ x = y &amp; &amp; \text{N} \ 1\\
3 &amp; &amp; \Box \ \forall x \ \exists y \ x = y \to \forall x \ \Box \ \exists y \ x =y &amp; &amp; \text{CBF} \\
4 &amp; &amp;\forall x \ \Box \ \exists y \ x =y  &amp; &amp; \text{MP} \ 2 3\\
\end{array}
\]</span></p>
<p>Here is another derivation of the theorem: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp; x= x &amp; &amp; \textsf{Ref} \\
2 &amp; &amp; x = x \to \exists y \ x = y &amp; &amp; \textsf{EG} \\
3 &amp; &amp; \Box \ x = x &amp; &amp; \textsf{RN} \ 1\\
4 &amp; &amp; \Box \ x = x \to \Box \ \exists y \ x = y &amp;  &amp; \textsf{RK} \ 2\\
5 &amp; &amp; \Box \ \exists y \ x = y &amp; &amp; \textsf{MP} \ 3, 4\\
6 &amp; &amp; \forall x \ \Box \ \exists y \ x = y &amp; &amp;  \textsf{UG} \ 5\\  
\end{array}
\]</span></p>
<p>Since we can necessitate the conclusion, we find that the simplest quantified modal logic proves that it is necessary that everything necessarily exists. This appears to fly in the face of common sense: do we not exist contingently?</p>
</section>
<section id="the-barcan-formula" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-barcan-formula">The Barcan Formula</h3>
<p>The Barcan Formula (<span class="math inline">\(\textsf{BF}\)</span>) is not a theorem of the simplest quantified modal logic, as we have described it, but its instances become derivable in the presence of axiom schema <span class="math inline">\(\textsf{B}\)</span>. <span class="math display">\[\tag{$\textsf{BF}$}
\forall x \  \Box \ \varphi \to \Box \ \forall x \ \varphi
\]</span> Given axiom <span class="math inline">\(\textsf{B}\)</span>, we have as a derived rule of inference: <span class="math display">\[\tag{$\textsf{DR}$}
\Diamond \ \varphi \to \psi/\varphi \to \Box \ \psi
\]</span> Here is a justification for the derived rule in KB:</p>
<p><span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \Diamond \ \varphi \to \psi &amp; &amp;   \\
2 &amp; &amp; \Box \ \Diamond \ \varphi \to \Box \ \psi &amp; &amp; \textsf{RK} \ 1\\
3 &amp; &amp; \varphi \to \Box \ \Diamond \ \varphi &amp; &amp; \textsf{B} \\
4 &amp; &amp; \varphi \to \Box \ \psi &amp; &amp; \textsf{PL} \ 2, 3\\
\end{array}
\]</span> We use the derived rule of inference for a derivation of BF in the presence of axiom B: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \forall x \ \Box \varphi \to \Box \varphi &amp; &amp;  \textsf{UI} \\
2 &amp; &amp; \Diamond \ \forall x \ \Box \varphi \to \Diamond \ \Box \ \varphi &amp; &amp; \textsf{RK} \ 1\\
3 &amp; &amp; \Diamond \ \Box \ \varphi \to \varphi &amp; &amp; \textsf{B}_\Diamond  \\
4 &amp; &amp; \Diamond \ \forall x \ \Box \varphi \to \varphi &amp; &amp; \textsf{PL} \ 2, 3\\
5 &amp; &amp; (\Diamond \ \forall x \ \Box \varphi \to  \varphi) \to (\Diamond \ \forall x \ \Box \varphi \to \forall x \ \varphi) &amp; &amp; \textsf{UG} \\
6 &amp; &amp; \Diamond \ \forall x \ \Box \varphi \to \forall x \ \varphi &amp; &amp; \textsf{MP} \ 4, 5 \\
7 &amp; &amp; \forall x \ \Box \varphi \to \Box \ \forall x \ \varphi &amp; &amp; \textsf{DR} \ 6 \\
\end{array}
\]</span></p>
<p>The derivability of BF is philosophically problematic: a physicalist may well accept that everything is necessarily a physical object but nevertheless make room for the possibility that non-physical objects exist. More dramatically, consider the converse of <span class="math inline">\(\textsf{BF}\)</span>:</p>
<p><span class="math display">\[
\Diamond \ \exists x \ \varphi \to \exists x \ \Diamond \ \varphi.
\]</span>So, for example, if it is possible for there to be unicorns, then something is possibly a unicorn.</p>
</section>
<section id="the-necessity-of-identity" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-necessity-of-identity">The Necessity of Identity</h3>
<p>We are in a position to establish the necessity of identity.</p>
<p><span class="math display">\[
\tag{NI}
x= y \to \Box \ x = y
\]</span></p>
<p>Here is a derivation: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  x = y \to (\Box  \ x=x \to \Box \ x =y) &amp; &amp;  \textsf{II} \\
2 &amp; &amp; x = x &amp; &amp; \textsf{RI} \\
3 &amp; &amp; \Box \ x=x  &amp; &amp;  \textsf{RN} \ 2 \\
4 &amp; &amp; x=y \to \Box \ x =y &amp; &amp; \textsf{PL} \ 1, 3 \\
\end{array}
\]</span></p>
</section>
<section id="the-necessity-of-distinctness" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-necessity-of-distinctness">The Necessity of Distinctness</h3>
<p>In the presence of axiom B, we can derive the necessity of distinctness: <span class="math display">\[
x \neq y \to \Box \ x \neq y  \tag{$\textsf{ND}$} \\
\]</span> Here is a simple argument: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \Diamond \  x \neq y \to x \neq y &amp; &amp;  \textsf{NI} \\
2 &amp; &amp; \Box \ \Diamond \  x \neq y \to \Box \ x \neq y &amp; &amp; \textsf{RK} \ 1\\
3 &amp; &amp; x \neq y \to \Box \ \Diamond x \neq y &amp; &amp; \textsf{B} \\
4 &amp; &amp; x \neq y \to \Box \ x \neq y &amp; &amp; \textsf{PL} \ 2, 3\\
\end{array}
\]</span></p>
<p>The role of axiom B appears to be crucial for the proof. Otherwise, we can provide a model of contingent distinctness by construing identity as indiscernibility and providing a model in which to discernible objects <em>can</em> become indiscernible at a world to which no other world in which the objects exemplify distinct properties is accessible.</p>
</section>
</section>
<section id="free-quantified-modal-logic" class="level2" data-number="14.4">
<h2 data-number="14.4" class="anchored" data-anchor-id="free-quantified-modal-logic"><span class="header-section-number">14.4</span> Free Quantified Modal Logic</h2>
<p>It is not uncommon to regard the provability of the Necessity of Existence in the simplest quantified modal logic as a powerful reason to weaken the axioms of the quanficational fragment of the system. This impression is sometimes reinforced by appeal to independent considerations.</p>
<section id="free-quantificational-logic" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="free-quantificational-logic">Free Quantificational Logic</h3>
<p>The axioms of quantificational logic have been independently questioned on the grounds that they deliver what some regard as objectionable consequences. There is, for example, the schema of Existential Generalization:</p>
<p><span class="math display">\[
\begin{array}{lll}
\varphi[y/x] \to \exists x \ \varphi(x) &amp; &amp; (\textsf{EG})\\
\end{array}
\]</span></p>
<p>The proof is simple:</p>
<p><span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp;  \forall x \ \neg \varphi(x) \to \neg \varphi(y) &amp; &amp;  \textsf{UI} \\
2 &amp; &amp; \neg \neg \varphi(y) \to \neg \forall x \neg \varphi(x) &amp; &amp; \textsf{PL}, 1 \\
3 &amp; &amp; \varphi(y) \to \neg \forall x \neg \varphi(x)  &amp; &amp;  \textsf{PL} \ 2 \\
4 &amp; &amp; \varphi(y) \to \exists x  \varphi(x) &amp; &amp; \textsf{Def} \ \exists, 3 \\
\end{array}
\]</span></p>
<p>There are at least two reasons philosophers have used to object to the schema:</p>
<ol type="1">
<li><p>In the presence of terms without denotation, the schema delivers unreasonable existential claims. If we include a term <span class="math inline">\(c\)</span> for Pegasus, say, into the language, then we learn that <span class="math inline">\(\exists x \ x = c\)</span>, which is absurd.</p></li>
<li><p>Existential generalization allows one to move from a universal generalization to an existential one, which conflicts with the thought that the former could have been true even in the absence of true instances.</p>
<p><span class="math display">\[
\vdash \forall x \ \varphi(x) \to \exists x \ \varphi(x)
\]</span></p></li>
</ol>
</section>
<section id="kripke-on-universal-instantiation" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="kripke-on-universal-instantiation">Kripke on Universal Instantiation</h3>
<p>Saul Kripke weakens the axiom of Universal Instantiation as follows: <span class="math display">\[
\forall y (\forall x \ \varphi(x) \to \varphi[y/x]) \tag{$\textsf{KFUI}$}
\]</span>where <span class="math inline">\(\varphi[y/x]\)</span> is, as usual, the formula that results when we replace every free occurrence of the variable <span class="math inline">\(x\)</span> in <span class="math inline">\(\varphi\)</span> with an occurrence of the variable <span class="math inline">\(y\)</span> making sure to reletter if necessary. Before we look at the proposal in some detail, we may consider Kripke’s own motivation for it. He has in mind the following derivation of an instance of the Converse Barcan Formula in the simplest quantified modal logic: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp; \forall x \ Fx \to Fy &amp; \textsf{UI} \\
2 &amp; &amp; \Box (\forall x \ Fx  \to Fy) &amp; \textsf{RN} \ 1 \\
3 &amp; &amp; \Box (\forall x \ Fx  \to Fy) \to (\Box \forall x \ Fx  \to \Box \ Fy) &amp; \textsf{K} \\
4 &amp; &amp; \Box \forall x \ Fx  \to \Box \ Fy  &amp; \textsf{PL} \ 2, 3 \\
5 &amp; &amp; \Box \forall x \ Fx  \to \forall x \ \Box \ Fx  &amp; \textsf{UG} \ 4 \\
\end{array}
\]</span> This is what he writes:</p>
<blockquote class="blockquote">
<p>Actually, the flaw lies in the application of necessitation to [1]. In a formula like [1], we give the free variables the generality interpretation: when [1] is asserted as a theorem, it abbreviates an assertion of its ordinary universal closure: <span class="math display">\[
\begin{array}{lllll}
[1'] &amp; \forall y (\forall x Fx \to Fy)
\end{array}
\]</span> Now, if we applied necessitation to [1’], we would get <span class="math display">\[
\begin{array}{lllll}
[2'] &amp; \Box \ \forall y \ (\forall x Fx \to Fy)
\end{array}
\]</span> On the other hand, [2] itself is interpreted as asserting: <span class="math display">\[
\begin{array}{lllll}
[2''] &amp; \forall y \ \Box  \  (\forall x Fx \to Fy)
\end{array}
\]</span> To infer [2’’] from [2’], we would need a law of the form <span class="math inline">\(\Box \ \forall y \ Cy \to \forall y \ \Box Cy\)</span>, which is just the converse Barcan formula we are trying to prove […]. We can avoid this sort of difficulty if, following Quine, we formulate quantification theory so that only closed formulae are asserted. Assertion of formulae containing free variables is at best a convenience; assertion of <span class="math inline">\(\varphi(x)\)</span> with free <span class="math inline">\(x\)</span> can always be replaced by assertion of <span class="math inline">\(\forall x \ \varphi(x)\)</span>.</p>
</blockquote>
<p>So, Kripke’s suggestion is to block the application of necessitation to open formulas by adopting a formulation of quantificational logic without open formulas as axioms. Hence the proposal to weaken UI to KFUI, which is its universal closure. As it turns out, Kripke’s proposal requires the adoption of a further quantificational axiom::<span class="math display">\[
\forall x \ \forall y \ Rxy \to   \forall y \ \forall x \ Rxy
\]</span> Notice that we are still in a position to define existence in terms of quantification and identity. What we no longer have is a derivation of existential generalization. At most, we are in a position to derive: <span class="math display">\[
\begin{array}{lllll}
1 &amp; &amp; \forall y \ (\forall x \ \neg \varphi(x) \to \neg \varphi(y)) &amp; &amp;  \textsf{KFUI} \\
2 &amp; &amp; \forall y (\neg \neg \varphi(y) \to \neg \forall x \neg \varphi(x)) &amp; &amp; \textsf{PL} \ 1\\
3 &amp; &amp; \forall y (\varphi(y) \to \neg \forall x \neg \varphi(x)) &amp; &amp; \textsf{PL} \ 2\\
4 &amp; &amp; \forall y (\varphi(y) \to \exists x  \varphi(x)) &amp; &amp; \textsf{Def} \ \exists \ 3\\
\end{array}
\]</span> We similarly have: <span class="math display">\[
\vdash \forall x \ (x = x \to \exists  y \ x =y)
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\vdash \forall x \ x = x \to \forall x \ \exists y \ x =y
\]</span>but either theorem is harmless when it comes to being able to derive the necessity of existence.</p>
</section>
</section>
<section id="semantics" class="level2" data-number="14.5">
<h2 data-number="14.5" class="anchored" data-anchor-id="semantics"><span class="header-section-number">14.5</span> Semantics</h2>
<p>We have distinguished at least two axiomatizations of quantified modal logic. We now proceed to explain how to interpret the language in order to validate the relevant axioms.</p>
<section id="constant-domain-models" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="constant-domain-models">Constant Domain Models</h3>
<p>We use constant domain models to interpret the simplest quantified modal logic.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Constant Domain Model
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <em>constant domain model</em> <span class="math inline">\(M\)</span> is a structure <span class="math inline">\((W, R, D, I)\)</span> where:</p>
<ol type="1">
<li><p><span class="math inline">\(W\)</span> is a non-empty set of <em>worlds</em></p></li>
<li><p><span class="math inline">\(R\)</span> is a binary <em>accessibility relation</em> on <span class="math inline">\(W\)</span></p></li>
<li><p><span class="math inline">\(D\)</span> is non-empty domain of <em>individuals</em></p></li>
<li><p><span class="math inline">\(I\)</span> is a function from worlds <span class="math inline">\(w\)</span> into interpretations <span class="math inline">\(I_w\)</span>, which map each <span class="math inline">\(n\)</span>-place predicate <span class="math inline">\(P^n\)</span> into an <span class="math inline">\(n\)</span>-place relation over <span class="math inline">\(D\)</span>.</p></li>
</ol>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variable Assignment
</div>
</div>
<div class="callout-body-container callout-body">
<p>A variable assignment <span class="math inline">\(\alpha\)</span> for a model <span class="math inline">\(M\)</span> is a function from individual variables into members of <span class="math inline">\(D\)</span>.</p>
</div>
</div>
<p>We now define what is for a formula <span class="math inline">\(\varphi\)</span> to be true at a world <span class="math inline">\(w\)</span> in a model <span class="math inline">\(M\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span>. In what follows, <span class="math inline">\(\alpha[x/d]\)</span> is an assignment just like <span class="math inline">\(\alpha\)</span> except perhaps for assigning <span class="math inline">\(d\)</span> to the variable <span class="math inline">\(x\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth at a World under an Assignment
</div>
</div>
<div class="callout-body-container callout-body">
<p>We use a recursive definition: <span class="math display">\[
\begin{array}{lll}
M, w, \alpha \Vdash P^n v_1 \dots v_n &amp; &amp; \text{iff} &amp; &amp; \langle \alpha(v_1), \dots, \alpha(v_n)\rangle \in I_w (P^n)\\
M, w,  \alpha  \Vdash v_1 = v_2   &amp; &amp; \text{iff} &amp; &amp;  \alpha(v_1) = \alpha(v_2)\\
M, w,  \alpha  \Vdash \neg \varphi &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha \nVdash \varphi \\
M, w,  \alpha  \Vdash  (\varphi \to \psi) &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha \nVdash \varphi \ \text{or} \ M, w, \alpha \Vdash \psi\\
M, w,  \alpha  \Vdash  \forall x \ \varphi &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha[x/d] \Vdash \varphi \ \text{for  every} \ d\in D\\
M, w,  \alpha  \Vdash  \Box  \ \varphi &amp; &amp; \text{iff} &amp; &amp; M, u, \alpha \Vdash \varphi \ \text{for every} \ u \in W \ \text{such that} \ Rwu\\
\end{array}
\]</span></p>
</div>
</div>
<p>We now define truth at a world and truth in a model as usual:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth at a World
</div>
</div>
<div class="callout-body-container callout-body">
<p>A formula <span class="math inline">\(\varphi\)</span> is true at a world <span class="math inline">\(w\)</span> in a model <span class="math inline">\(M\)</span>, in symbols <span class="math inline">\(M, w \Vdash \varphi\)</span>, if, and only if, for all assignments <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>, <span class="math inline">\(M, w, \alpha \Vdash \varphi\)</span></p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth in a Model
</div>
</div>
<div class="callout-body-container callout-body">
<p>A formula <span class="math inline">\(\varphi\)</span> is true in a model <span class="math inline">\(M\)</span>, in symbols, <span class="math inline">\(M \Vdash \varphi\)</span>, if, and only. if, for all <span class="math inline">\(w \in  W\)</span>, <span class="math inline">\(M, w \Vdash \varphi\)</span>.</p>
</div>
</div>
<p>By way of example, consider the fact that <span class="math inline">\(\exists x \neg \Box Fx \to \Diamond \forall x \neg Fx\)</span> is not true in every reflexive and euclidean constant domain model.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(\not \models_{\text{refl and eucl}} \exists x \neg \Box Fx \to \Diamond \forall x \neg Fx\)</span></p>
<p>Consider a constant domain model <span class="math inline">\(M\)</span> of the form <span class="math inline">\(( W, R, D, I)\)</span>, where:</p>
<ul>
<li><p><span class="math inline">\(W = \{w_1, w_2\}\)</span></p></li>
<li><p><span class="math inline">\(R = \{(w_1, w_1), ( w_1, w_2), (w_2, w_1), (w_2, w_2)\}\)</span></p></li>
<li><p><span class="math inline">\(D = \{a, b\}\)</span></p></li>
<li><p><span class="math inline">\(I_{w_1}(F) = \{a\}\)</span></p>
<p><span class="math inline">\(I_{w_2}(F) = \{b\}\)</span></p></li>
</ul>
<p>For a diagram, consider:</p>
<p><img src="images/clipboard-1176484358.png" class="img-fluid"></p>
<p>Now:</p>
<ul>
<li><p><span class="math inline">\(M, w_1 \Vdash \exists x \neg \Box Fx\)</span> because <span class="math inline">\(M, w_1, \alpha[b/x] \Vdash \neg \Box Fx\)</span></p></li>
<li><p><span class="math inline">\(M, w_1 \nVdash \Diamond \forall x \neg Fx\)</span> because <span class="math inline">\(M, w_1 \Vdash \forall x \neg Fx\)</span> and <span class="math inline">\(Rw_1w_1\)</span>.</p></li>
</ul>
</div>
</div>
<p>On the other hand, we may verify that constant domain models validate both the Barcan Formula and the Converse Barcan Formula:</p>
<div class="proposition">
<p><span class="math inline">\(\models  \Diamond \ \exists x \ Fx \to \exists x \ \Diamond \ Fx\)</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Given a constant domain model <span class="math inline">\(M\)</span> and a world <span class="math inline">\(w\in W\)</span> such that <span class="math inline">\(M, w \Vdash \Diamond \ \exists x \ Fx\)</span>, let <span class="math inline">\(u \in W\)</span> be such that <span class="math inline">\(Rwu\)</span> and <span class="math inline">\(M, u \Vdash \exists x \ Fx\)</span>. That means that there is a member <span class="math inline">\(d \in D\)</span> such that for each assignment <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(M, u, \alpha[d/x] \Vdash Fx\)</span>. But then <span class="math inline">\(M, w, \alpha[d/x]\Vdash \Diamond \ Fx\)</span> and, moreover, <span class="math inline">\(M, w, \alpha \Vdash \exists x \ \Diamond \ Fx\)</span>. Since <span class="math inline">\(\alpha\)</span> is arbitrary, <span class="math inline">\(M, w \Vdash \Diamond \ \exists x \ Fx\)</span> as required.</p>
</div>
<div class="proposition">
<p><span class="math inline">\(\models  \Box \ \forall x \ Fx \to \forall x \ \Box \ Fx\)</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Given a constant domain model <span class="math inline">\(M\)</span> and a world <span class="math inline">\(w\in W\)</span> such that <span class="math inline">\(M, w \Vdash \Box \ \forall x \ Fx\)</span>, we argue that <span class="math inline">\(M, w \Vdash \forall x \ \Box \ Fx\)</span>. For given an assignment <span class="math inline">\(\alpha\)</span> and a member <span class="math inline">\(d \in D\)</span>, <span class="math inline">\(M, w,  \alpha[d/x] \Vdash \Box Fx\)</span>. This is because given a world <span class="math inline">\(u\in W\)</span> such that <span class="math inline">\(Rwu\)</span>, we have <span class="math inline">\(M, u \Vdash \forall x Fx\)</span> and <span class="math inline">\(M, u, \alpha[d/x]\Vdash Fx\)</span>. Since <span class="math inline">\(u\)</span> and <span class="math inline">\(d\)</span> Are arbitrary, <span class="math inline">\(M, w \Vdash \forall x \ \Box \ Fx\)</span> as required.</p>
</div>
</section>
<section id="variable-domain-models" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="variable-domain-models">Variable Domain Models</h3>
<p>We now turn attention to variable domain models, which we use to validate weaker fragments of quantified modal logic.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variable Domain Model
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <em>variable domain model</em> <span class="math inline">\(M\)</span> is a structure <span class="math inline">\((W, R, D, Q, I)\)</span> where:</p>
<ol type="1">
<li><p><span class="math inline">\(W\)</span> is a non-empty set of <em>worlds</em></p></li>
<li><p><span class="math inline">\(R\)</span> is a binary <em>accessibility relation</em> on <span class="math inline">\(W\)</span></p></li>
<li><p><span class="math inline">\(D\)</span> is non-empty domain of <em>individuals,</em> which we call the <em>outer domain</em>.</p></li>
<li><p><span class="math inline">\(Q\)</span> is function from <span class="math inline">\(W\)</span> into subsets of <span class="math inline">\(D\)</span>, and we will call <span class="math inline">\(Q(w)\)</span> the <em>inner domain</em> of <span class="math inline">\(w\)</span> for each <span class="math inline">\(w \in W\)</span></p></li>
<li><p><span class="math inline">\(I\)</span> is a function from worlds <span class="math inline">\(w\)</span> into interpretations <span class="math inline">\(I_w\)</span>, which map each <span class="math inline">\(n\)</span>-place predicate <span class="math inline">\(P^n\)</span> into an <span class="math inline">\(n\)</span>-place relation over <span class="math inline">\(D\)</span>.</p></li>
</ol>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variable Assignment
</div>
</div>
<div class="callout-body-container callout-body">
<p>A variable assignment <span class="math inline">\(\alpha\)</span> for a model <span class="math inline">\(M\)</span> is a function from individual variables into members of <span class="math inline">\(D\)</span>.</p>
</div>
</div>
<p>The evaluation of an open formula such as <span class="math inline">\(Fx\)</span> at a world <span class="math inline">\(w\)</span> in <span class="math inline">\(W\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span> raises an important question. What should we make of a case in which <span class="math inline">\(\alpha(x)\)</span> is <em>not</em> in the inner domain of <span class="math inline">\(w\)</span>. Three broad strategies come to mind:</p>
<ol type="1">
<li><p><em>Avoidance</em></p>
<p>Find a way to exclude such assignments in principle.</p></li>
<li><p><em>Unsettled Truth Value</em></p>
<p>Declare an open formula such as <span class="math inline">\(Fx\)</span> to be neither true nor false in that circumstance.</p></li>
<li><p><em>Deference</em></p>
<p>Defer to the interpretation function <span class="math inline">\(I\)</span> in order to settle the truth value of open formulas such as <span class="math inline">\(Fx\)</span>.</p></li>
</ol>
<p>In what follows, we will adopt the third approach and let the interpretation function settle the truth value of the open formula at a world relative to that assignment. That means that a formula <span class="math inline">\(Fx\)</span> can in principle be true at a world <span class="math inline">\(w\)</span> in a model <span class="math inline">\(M\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span> on which <span class="math inline">\(\alpha(x)\)</span> is not even a member of <span class="math inline">\(Q(w)\)</span>.</p>
<p>We now define what is for a formula <span class="math inline">\(\varphi\)</span> to be true at a world <span class="math inline">\(w\)</span> in a model <span class="math inline">\(M\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span>. In what follows, <span class="math inline">\(\alpha[x/d]\)</span> is an assignment just like <span class="math inline">\(\alpha\)</span> except perhaps for assigning <span class="math inline">\(d\)</span> to the variable <span class="math inline">\(x\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth at a Word under an Assignment
</div>
</div>
<div class="callout-body-container callout-body">
<p>We use a recursive definition: <span class="math display">\[
\begin{array}{lll}
M, w, \alpha \Vdash P^n v_1 \dots v_n &amp; &amp; \text{iff} &amp; &amp; \langle \alpha(v_1), \dots, \alpha(v_n)\rangle \in I_w (P^n)\\
M, w,  \alpha  \Vdash v_1 = v_2   &amp; &amp; \text{iff} &amp; &amp;  \alpha(v_1) = \alpha(v_2)\\
M, w,  \alpha  \Vdash \neg \varphi &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha \nVdash \varphi \\
M, w,  \alpha  \Vdash  (\varphi \to \psi) &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha \nVdash \varphi \ \text{or} \ M, w, \alpha \Vdash \psi\\
M, w,  \alpha  \Vdash  \forall x \ \varphi &amp; &amp; \text{iff} &amp; &amp; M, w, \alpha[x/d] \Vdash \varphi \ \text{for  every} \ d\in Q(w)\\
M, w,  \alpha  \Vdash  \Box  \ \varphi &amp; &amp; \text{iff} &amp; &amp; M, u, \alpha \Vdash \varphi \ \text{for every} \ u \in W \ \text{such that} \ Rwu\\
\end{array}
\]</span></p>
</div>
</div>
<p>We now define truth at a world and truth in a model as usual:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth at a World
</div>
</div>
<div class="callout-body-container callout-body">
<p>A formula <span class="math inline">\(\varphi\)</span> is true at a world <span class="math inline">\(w\)</span> in a model <span class="math inline">\(M\)</span>, in symbols <span class="math inline">\(M, w \Vdash \varphi\)</span>, if, and only if, for all assignments <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>, <span class="math inline">\(M, w, \alpha \Vdash \varphi\)</span></p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Truth in a Model
</div>
</div>
<div class="callout-body-container callout-body">
<p>A formula <span class="math inline">\(\varphi\)</span> is true in a model <span class="math inline">\(M\)</span>, in symbols, <span class="math inline">\(M \Vdash \varphi\)</span>, if, and only. if, for all <span class="math inline">\(w \in  W\)</span>, <span class="math inline">\(M, w \Vdash \varphi\)</span>.</p>
</div>
</div>
<p>One important consequence of the choices we made above is that universal instantiation fails in variable domain models. Consider, for example, the evaluation of an instance of Universal Instantiation at a world <span class="math inline">\(w\)</span> of a variable domain model:</p>
<p><span class="math display">\[
\forall x Fx \to Fy
\]</span></p>
<p>relative to an assignment <span class="math inline">\(\alpha\)</span>, which maps <span class="math inline">\(y\)</span> to an individual that is neither in the inner domain of <span class="math inline">\(w\)</span> nor in the extension of <span class="math inline">\(F\)</span> in <span class="math inline">\(w\)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(\not \models \Box \forall x Fx \to \forall x \Box Fx\)</span>.</p>
<p>Consider a variable domain model <span class="math inline">\(M\)</span> of the form <span class="math inline">\(( W, R, D, Q, I)\)</span>, where:</p>
<ul>
<li><span class="math inline">\(W = \{w_1, w_2\}\)</span></li>
<li><span class="math inline">\(R= \{(w_1, w_1), (w_1, w_2), (w_2, w_1), (w_2, w_2)\}\)</span></li>
<li><span class="math inline">\(D = \{a, b\}\)</span></li>
<li><span class="math inline">\(Q(w_1) = \{a\}\)</span></li>
<li><span class="math inline">\(Q(w_2) = \{b\}\)</span></li>
<li><span class="math inline">\(I_{w_1}(F) = \{a\}\)</span></li>
<li><span class="math inline">\(I_{w_2}(F) = \{b\}\)</span></li>
</ul>
<p>Now:</p>
<ul>
<li><p><span class="math inline">\(M, w_1 \Vdash \Box \forall x Fx\)</span>.</p>
<p>This is because for every assignment <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>, we have both <span class="math inline">\(M, w_1, \alpha \Vdash \forall x Fx\)</span> and <span class="math inline">\(M, w_2, \alpha \Vdash \forall x Fx\)</span>.</p></li>
<li><p><span class="math inline">\(M, w_1 \nVdash \forall x \Box Fx\)</span></p>
<p>Given an assignment <span class="math inline">\(\alpha\)</span> for which <span class="math inline">\(\alpha(x)= a\)</span>, <span class="math inline">\(M, w_1, \alpha \nVdash \Box Fx\)</span>, since <span class="math inline">\(M, w_2, \alpha \nVdash Fx\)</span> and <span class="math inline">\(Rw_1w_2\)</span>.</p></li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(\not \models \forall x \Box Fx \to \Box \forall x Fx\)</span>.</p>
<p>Consider a variable domain model <span class="math inline">\(M\)</span> of the form <span class="math inline">\(( W, R, D, Q, I)\)</span>, where:</p>
<ul>
<li><span class="math inline">\(W = \{w_1, w_2\}\)</span></li>
<li><span class="math inline">\(R= \{(w_1, w_1), (w_1, w_2), (w_2, w_1), (w_2, w_2)\}\)</span></li>
<li><span class="math inline">\(D = \{a, b\}\)</span></li>
<li><span class="math inline">\(Q(w_1) = \{a\}\)</span></li>
<li><span class="math inline">\(Q(w_2) = \{a, b\}\)</span></li>
<li><span class="math inline">\(I_{w_1}(F) = \{a\}\)</span></li>
<li><span class="math inline">\(I_{w_2}(F) = \{a\}\)</span></li>
</ul>
<p>Now:</p>
<ul>
<li><p><span class="math inline">\(M, w_1 \Vdash \forall x \Box Fx\)</span>.</p>
<p>This is because for every assignment <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>, for every <span class="math inline">\(d \in Q(w_1)\)</span>, we have both <span class="math inline">\(M, w_1, \alpha[d/x] \Vdash Fx\)</span> and <span class="math inline">\(M, w_2, \alpha[d/x] \Vdash Fx\)</span>. In this case, <span class="math inline">\(a\)</span> is the sole member of the inner domain of <span class="math inline">\(w_1\)</span>.</p></li>
<li><p><span class="math inline">\(M, w_1 \nVdash \Box \forall x  Fx\)</span></p>
<p>Given an assignment <span class="math inline">\(\alpha\)</span> , <span class="math inline">\(M, w_1, \alpha \nVdash \Box \forall Fx\)</span>, since <span class="math inline">\(M, w_2, \alpha \nVdash \forall x Fx\)</span> and <span class="math inline">\(Rw_1w_2\)</span>.</p></li>
</ul>
</div>
</div>
<section id="the-inclusion-and-converse-inclusion-requirement" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="the-inclusion-and-converse-inclusion-requirement">The Inclusion and Converse Inclusion Requirement</h4>
<p>Two broad constraints on variable domain models allow us to isolate the class of such models in which the Converse Barcan and the Barcan Formula are valid, respectively, in variable domain models.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Inclusion Requirement
</div>
</div>
<div class="callout-body-container callout-body">
<p>A variable domain model <span class="math inline">\(M\)</span> of the form <span class="math inline">\(( W, R, D, Q, I)\)</span> satisfies the <em>inclusion requirement</em> if, and only if, for every <span class="math inline">\(w, u \in W\)</span>, if <span class="math inline">\(Rwu\)</span>, then. <span class="math inline">\(Q(w) \subseteq Q(u)\)</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Converse Inclusion Requirement
</div>
</div>
<div class="callout-body-container callout-body">
<p>A variable domain model <span class="math inline">\(M\)</span> of the form <span class="math inline">\(( W, R, D, Q, I)\)</span> satisfies the <em>converse inclusion requirement</em> if, and only if, for every <span class="math inline">\(w, u \in W\)</span>, if <span class="math inline">\(Rwu\)</span>, then. <span class="math inline">\(Q(u) \subseteq Q(w)\)</span>.</p>
</div>
</div>
<p>That is, a variable domain model satisfies the inclusion requirement if the inner domains never decrease alongside the accessibility relation; and it satisfies the converse inclusion requirement if the inner domains never increase alongside the accessibility relation.</p>
<div id="prp-cbf" class="proposition theorem">
<p><span class="theorem-title"><strong>Proposition 14.1</strong></span> The Converse Barcan Formula is valid in variable domain model satisfying the inclusion requirement.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(M\)</span> be a variable domain model of the form <span class="math inline">\(( W, R, D, I)\)</span> satisfying the inclusion requirement. Choose a world <span class="math inline">\(w \in W\)</span> and an assignment <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>. We argue that <span class="math inline">\(M, w, \alpha \Vdash \Box \forall x \varphi(x) \to \forall x \Box \varphi(x)\)</span>. Since the formula is a conditional, assume that <span class="math inline">\(M, w, \alpha \Vdash \Box \forall x \varphi(x)\)</span>. That means that <span class="math inline">\(M, u, \alpha \Vdash \forall x \varphi(x)\)</span> for all <span class="math inline">\(u\in W\)</span> such that <span class="math inline">\(Rwu\)</span>. We now argue that <span class="math inline">\(M, w, \alpha \Vdash \forall x \Box \varphi(x)\)</span>. That is that for every <span class="math inline">\(d\in Q(w)\)</span>, <span class="math inline">\(M, w, \alpha[d/x]\Vdash \Box \varphi(x)\)</span>. Pick a member <span class="math inline">\(d\in Q(w)\)</span> and let <span class="math inline">\(u\in W\)</span> be such that <span class="math inline">\(Rwu\)</span>. <em>Because</em> <span class="math inline">\(M\)</span> satisfies the inclusion requirement, <span class="math inline">\(d\in Q(u)\)</span>. Since <span class="math inline">\(M, u, \alpha \Vdash \forall x \varphi(x)\)</span> and <span class="math inline">\(d\in Q(u)\)</span>, <span class="math inline">\(M, u, \alpha[d/x]\Vdash \varphi(x)\)</span>. We conclude that <span class="math inline">\(M, w, \alpha \Vdash \Box \forall x \varphi(x) \to \forall x \Box \varphi(x)\)</span> And, more generally, <span class="math inline">\(M, w \Vdash \Box \forall x \varphi(x) \to \forall x \Box \varphi(x)\)</span></p>
</div>
<div id="prp-bf" class="proposition theorem">
<p><span class="theorem-title"><strong>Proposition 14.2</strong></span> The Barcan Formula is valid in variable domain models satisfying the converse inclusion requirement.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(M\)</span> be a variable domain model of the form <span class="math inline">\(( W, R, D, I)\)</span> satisfying the converse inclusion requirement. Choose a world <span class="math inline">\(w \in W\)</span> and an assignment <span class="math inline">\(\alpha\)</span> for <span class="math inline">\(M\)</span>. We argue that <span class="math inline">\(M, w, \alpha \Vdash \forall x \Box \varphi(x) \to \Box \forall x \varphi(x)\)</span>. Since the formula is a conditional, assume that <span class="math inline">\(M, w, \alpha \Vdash \forall x \Box \varphi(x)\)</span>. That means that <span class="math inline">\(M, u, \alpha[d/x] \Vdash \Box \varphi(x)\)</span> for all <span class="math inline">\(d\in Q(w)\)</span>. We now argue that <span class="math inline">\(M, w, \alpha \Vdash \Box \forall x \varphi(x)\)</span>. That is that for every <span class="math inline">\(u\in W\)</span> such that <span class="math inline">\(Rwu\)</span>, <span class="math inline">\(M, u, \alpha \Vdash \forall x \varphi(x)\)</span>. Pick a word <span class="math inline">\(u\in W\)</span> such that <span class="math inline">\(Rwu\)</span> and let <span class="math inline">\(d \in Q(u)\)</span>. <em>Because</em> <span class="math inline">\(M\)</span> satisfies the converse inclusion requirement, <span class="math inline">\(d\in Q(w)\)</span>. Since <span class="math inline">\(M, w, \alpha[d/x] \Vdash \Box \varphi(x)\)</span> and <span class="math inline">\(M, u, \alpha[d/x] \Vdash \varphi(x)\)</span>. So, generalizing, <span class="math inline">\(M, u, \alpha \Vdash \forall x \varphi(x)\)</span> and <span class="math inline">\(M, w, \alpha \Vdash \Box \forall x \varphi(x)\)</span>. We conclude that <span class="math inline">\(M, w, \alpha \Vdash \forall x \Box \varphi(x) \to \Box \forall x \varphi(x)\)</span> And <span class="math inline">\(M, w, \alpha \Vdash \forall x \Box \varphi(x) \to \Box \forall x \varphi(x)\)</span>.</p>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./conditionals.html" class="pagination-link" aria-label="Conditionals">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Conditionals</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>